import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin } from '@/lib/supabase/client';
import * as jose from 'jose';

export const runtime = 'edge';

// 현재 사용자 정보 추출
async function getCurrentUser(request: NextRequest): Promise<{ id: string; email?: string } | null> {
  try {
    const token = request.cookies.get('session')?.value
      || request.cookies.get('auth-token')?.value;
    if (!token) return null;
    
    const decoded = jose.decodeJwt(token);
    const id = decoded.sub as string | undefined;
    const email = decoded.email as string | undefined;
    if (!id) return null;
    return { id, email };
  } catch {
    return null;
  }
}

interface ServiceData {
  id?: string;
  name: string;
  nameKo?: string;
  description: string;
  descriptionKo?: string;
  homepage: string;
  apiBase: string;
  autoParse?: boolean; // true면 sampleUrl을 자동 파싱
  productPage?: {
    urlPattern?: string;
    sampleUrl?: string;
    dataSource?: 'json-ld' | 'meta' | 'dom' | 'api';
    selectors?: {
      title?: string;
      price?: string;
      currency?: string;
      image?: string;
      description?: string;
      sku?: string;
      brand?: string;
      availability?: string;
      rating?: string;
      reviewCount?: string;
    };
    notes?: string;
    // 자동 파싱 결과 저장
    parsedData?: {
      jsonLd?: object[];
      sampleProducts?: {
        name: string;
        price?: string;
        image?: string;
        url?: string;
      }[];
      meta?: Record<string, string>;
      parsedAt?: string;
    };
  };
  endpoints: {
    id: string;
    path: string;
    method: string;
    description: string;
    auth: boolean;
    params: string;
  }[];
  authType: string;
  rateLimit: string;
  contactEmail: string;
  slug?: string;
  createdAt?: string;
}

// 메모리 저장소 (DB 미연결 시 폴백)
const servicesStore = new Map<string, ServiceData & { aiTxt: string; jsonLd: object }>();

// 슬러그 생성 (간단한 버전)
function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 30) + '-' + Date.now().toString(36);
}

// ai.txt 형식으로 변환
function generateAiTxt(service: ServiceData, slug: string): string {
  const productPage = service.productPage;
  const hasProductInfo = Boolean(
    productPage?.urlPattern
    || productPage?.sampleUrl
    || productPage?.dataSource
    || productPage?.notes
    || Object.values(productPage?.selectors || {}).some(Boolean)
  );

  return `# =============================================================================
# ${service.name} AI Interaction Specification (ai.txt)
# Generated by Eoynx Agent Gateway
# Hosted at: https://eoynx.com/s/${slug}
# =============================================================================

[System.Context]
Name: ${service.name}
${service.nameKo ? `Name_KO: ${service.nameKo}` : ''}
Description: ${service.description}
${service.descriptionKo ? `Description_KO: ${service.descriptionKo}` : ''}
Homepage: ${service.homepage}
Contact: ${service.contactEmail}

[API.Base]
URL: ${service.apiBase}

[API.Endpoints]
${service.endpoints.map((ep, i) => `
## ${i + 1}. ${ep.description || 'Endpoint'}
Endpoint: ${ep.method} ${service.apiBase}${ep.path}
Auth: ${ep.auth ? 'Required' : 'Not Required'}
${ep.params ? `Parameters: ${ep.params}` : ''}`).join('\n')}

[Authentication.Policy]
Type: ${service.authType === 'none' ? 'None' : service.authType === 'api_key' ? 'API Key' : service.authType === 'jwt' ? 'JWT Bearer Token' : 'OAuth 2.0'}
${service.authType !== 'none' ? `Header: ${service.authType === 'api_key' ? 'X-API-Key' : 'Authorization: Bearer <token>'}` : ''}

[Rate.Limits]
Default: ${service.rateLimit}

${hasProductInfo ? `
[Product.Page]
URL_Pattern: ${productPage?.urlPattern || ''}
Sample_URL: ${productPage?.sampleUrl || ''}
Data_Source: ${productPage?.dataSource || ''}
${productPage?.selectors ? `Selectors:
  Title: ${productPage.selectors.title || ''}
  Price: ${productPage.selectors.price || ''}
  Currency: ${productPage.selectors.currency || ''}
  Image: ${productPage.selectors.image || ''}
  Description: ${productPage.selectors.description || ''}
  SKU: ${productPage.selectors.sku || ''}
  Brand: ${productPage.selectors.brand || ''}
  Availability: ${productPage.selectors.availability || ''}
  Rating: ${productPage.selectors.rating || ''}
  ReviewCount: ${productPage.selectors.reviewCount || ''}
` : ''}
${productPage?.notes ? `Notes: ${productPage.notes}` : ''}
` : ''}

# =============================================================================
# Generated via Eoynx Agent Gateway
# https://eoynx.com
# =============================================================================
`;
}

// JSON-LD 형식으로 변환
function generateJsonLd(service: ServiceData, slug: string): object {
  const productPage = service.productPage;
  return {
    '@context': 'https://schema.org',
    '@type': 'WebAPI',
    '@id': `https://eoynx.com/s/${slug}`,
    name: service.name,
    alternateName: service.nameKo || undefined,
    description: service.description,
    url: service.homepage,
    documentation: `${service.homepage}/docs`,
    provider: {
      '@type': 'Organization',
      name: service.name,
      email: service.contactEmail,
    },
    endpointUrl: service.apiBase,
    potentialAction: service.endpoints.map(ep => ({
      '@type': ep.method === 'GET' ? 'ReadAction' : 'Action',
      name: ep.description || ep.path,
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${service.apiBase}${ep.path}`,
        httpMethod: ep.method,
      },
    })),
    additionalProperty: [
      {
        '@type': 'PropertyValue',
        name: 'authType',
        value: service.authType,
      },
      {
        '@type': 'PropertyValue',
        name: 'rateLimit',
        value: service.rateLimit,
      },
      ...(productPage ? [
        {
          '@type': 'PropertyValue',
          name: 'productPage',
          value: productPage,
        },
      ] : []),
    ],
  };
}

function extractProductPage(jsonLd: unknown): ServiceData['productPage'] | undefined {
  if (!jsonLd || typeof jsonLd !== 'object') return undefined;
  const additional = (jsonLd as Record<string, unknown>).additionalProperty;
  if (!Array.isArray(additional)) return undefined;
  const productProperty = additional.find((item) => (item as Record<string, unknown>)?.name === 'productPage');
  const value = (productProperty as Record<string, unknown> | undefined)?.value;
  if (value && typeof value === 'object') return value as ServiceData['productPage'];
  return undefined;
}

export async function POST(request: NextRequest) {
  try {
    let serviceData: ServiceData = await request.json();
    
    // 현재 사용자 ID 가져오기
    const currentUser = await getCurrentUser(request);
    if (!currentUser) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    const effectiveName = serviceData.name || serviceData.nameKo;
    const effectiveDescription = serviceData.description || serviceData.descriptionKo;

    // 필수 필드 검증
    if (!effectiveName || !serviceData.apiBase || !effectiveDescription) {
      return NextResponse.json(
        { error: 'Missing required fields: name, apiBase, description' },
        { status: 400 }
      );
    }

    // 자동 파싱: sampleUrl이 있고 autoParse가 true면 내부 API 호출
    if (serviceData.autoParse && serviceData.productPage?.sampleUrl) {
      try {
        const baseUrl = request.headers.get('host') || 'localhost:3000';
        const protocol = request.headers.get('x-forwarded-proto') || 'http';
        const autoParseUrl = `${protocol}://${baseUrl}/api/services/auto-parse`;
        
        const parseResponse = await fetch(autoParseUrl, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'Cookie': request.headers.get('cookie') || '',
          },
          body: JSON.stringify({
            url: serviceData.productPage.sampleUrl,
            timeout: 25000,
            isProductPage: true,
          }),
        });
        
        if (parseResponse.ok) {
          const parseResult = await parseResponse.json();
          if (parseResult.success && parseResult.data) {
            // 파싱 결과로 productPage 업데이트
            serviceData = {
              ...serviceData,
              productPage: {
                ...serviceData.productPage,
                urlPattern: parseResult.data.urlPattern || serviceData.productPage?.urlPattern,
                dataSource: parseResult.data.dataSource || serviceData.productPage?.dataSource,
                selectors: parseResult.data.suggestedSelectors || serviceData.productPage?.selectors,
                parsedData: {
                  jsonLd: parseResult.data.jsonLd,
                  sampleProducts: parseResult.data.products,
                  meta: parseResult.data.meta,
                  parsedAt: parseResult.data.parsedAt,
                },
              },
            };
          }
        }
      } catch (parseError) {
        console.warn('Auto-parse failed, continuing with manual data:', parseError);
        // 자동 파싱 실패해도 서비스 등록은 계속 진행
      }
    }
    
    // 슬러그 생성
    const normalizedService: ServiceData = {
      ...serviceData,
      name: effectiveName,
      description: effectiveDescription,
    };

    const slug = generateSlug(normalizedService.name);
    const id = crypto.randomUUID();
    const now = new Date().toISOString();
    const aiTxt = generateAiTxt(normalizedService, slug);
    const jsonLd = generateJsonLd(normalizedService, slug);
    
    const supabase = getSupabaseAdmin();
    
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const sb = supabase as any;
    
    // Supabase에 저장 시도
    const { data, error } = await sb
      .from('services')
      .insert({
        id,
        slug,
        user_id: currentUser.id,
        name: normalizedService.name,
        name_ko: serviceData.nameKo,
        description: normalizedService.description,
        description_ko: serviceData.descriptionKo,
        homepage: serviceData.homepage,
        api_base: serviceData.apiBase,
        endpoints: serviceData.endpoints,
        auth_type: serviceData.authType,
        rate_limit: serviceData.rateLimit,
        contact_email: serviceData.contactEmail,
        ai_txt: aiTxt,
        json_ld: jsonLd,
        created_at: now,
      })
      .select()
      .single();
    
    if (error) {
      if (error.message?.includes('column "user_id" does not exist')) {
        const { data: retryData, error: retryError } = await sb
          .from('services')
          .insert({
            id,
            slug,
            name: normalizedService.name,
            name_ko: serviceData.nameKo,
            description: normalizedService.description,
            description_ko: serviceData.descriptionKo,
            homepage: serviceData.homepage,
            api_base: serviceData.apiBase,
            endpoints: serviceData.endpoints,
            auth_type: serviceData.authType,
            rate_limit: serviceData.rateLimit,
            contact_email: serviceData.contactEmail,
            ai_txt: aiTxt,
            json_ld: jsonLd,
            created_at: now,
          })
          .select()
          .single();

        if (retryError) {
          return NextResponse.json(
            { error: 'Failed to save service', details: retryError.message },
            { status: 500 }
          );
        }

        return NextResponse.json({
          success: true,
          slug,
          service: {
            id: retryData?.id || id,
            slug: retryData?.slug || slug,
            name: normalizedService.name,
            createdAt: retryData?.created_at || now,
            urls: {
              dashboard: `https://eoynx.com/s/${slug}`,
              aiTxt: `https://eoynx.com/s/${slug}/ai.txt`,
              llmsTxt: `https://eoynx.com/s/${slug}/llms.txt`,
              jsonLd: `https://eoynx.com/s/${slug}/json-ld`,
            },
          },
          preview: {
            aiTxt,
            jsonLd,
          },
        }, {
          status: 201,
          headers: {
            'Content-Type': 'application/json',
          },
        });
      }

      if (error.message?.includes('Supabase not configured')) {
        console.warn('DB save failed, using memory store:', error.message);
        // 메모리에 저장
        servicesStore.set(id, {
          ...normalizedService,
          id,
          slug,
          createdAt: now,
          aiTxt,
          jsonLd,
        });
      } else {
        return NextResponse.json(
          { error: 'Failed to save service', details: error.message },
          { status: 500 }
        );
      }
    }
    
    const result = {
      id: data?.id || id,
      slug: data?.slug || slug,
      name: normalizedService.name,
      createdAt: data?.created_at || now,
      urls: {
        dashboard: `https://eoynx.com/s/${slug}`,
        aiTxt: `https://eoynx.com/s/${slug}/ai.txt`,
        llmsTxt: `https://eoynx.com/s/${slug}/llms.txt`,
        jsonLd: `https://eoynx.com/s/${slug}/json-ld`,
      },
    };
    
    return NextResponse.json({
      success: true,
      slug,
      service: result,
      preview: {
        aiTxt,
        jsonLd,
      },
    }, {
      status: 201,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  } catch (error) {
    console.error('Service creation error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { 
        error: 'Failed to create service',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const slug = searchParams.get('slug');
    const id = searchParams.get('id');
    const myOnly = searchParams.get('my') === 'true';
    
    const supabase = getSupabaseAdmin();
    
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const sb = supabase as any;
    
    // 특정 slug로 조회
    if (slug) {
      const { data, error } = await sb
        .from('services')
        .select('*')
        .eq('slug', slug)
        .single();
      
      if (error || !data) {
        // 메모리에서 조회
        for (const [, service] of servicesStore) {
          if (service.slug === slug) {
            return NextResponse.json({
              success: true,
              service,
            });
          }
        }
        return NextResponse.json(
          { error: 'Service not found' },
          { status: 404 }
        );
      }

      return NextResponse.json({
        success: true,
        service: {
          ...data,
          productPage: extractProductPage(data?.json_ld),
        },
      });
    }

    // 특정 id로 조회 (내 서비스 편집용)
    if (id) {
      const currentUser = await getCurrentUser(request);
      if (!currentUser) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        );
      }

      const { data, error } = await sb
        .from('services')
        .select('*')
        .eq('id', id)
        .single();

      if (error || !data) {
        return NextResponse.json(
          { error: 'Service not found' },
          { status: 404 }
        );
      }

      if (data.user_id && data.user_id !== currentUser.id) {
        return NextResponse.json(
          { error: 'Permission denied' },
          { status: 403 }
        );
      }

      if (!data.user_id && currentUser.email && data.contact_email && data.contact_email !== currentUser.email) {
        return NextResponse.json(
          { error: 'Permission denied' },
          { status: 403 }
        );
      }

      return NextResponse.json({
        success: true,
        service: {
          ...data,
          productPage: extractProductPage(data?.json_ld),
        },
      });
    }
    
    // 내 서비스만 조회
    if (myOnly) {
      const currentUser = await getCurrentUser(request);
      if (!currentUser) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        );
      }
      
      const { data, error } = await sb
        .from('services')
        .select('id, name, description, slug, api_base, created_at')
        .eq('user_id', currentUser.id)
        .order('created_at', { ascending: false });
      
      if (error) {
        if (error.message?.includes('column "user_id" does not exist')) {
          if (!currentUser.email) {
            return NextResponse.json({
              success: true,
              services: [],
            });
          }
          const { data: emailData, error: emailError } = await sb
            .from('services')
            .select('id, name, description, slug, api_base, created_at')
            .eq('contact_email', currentUser.email)
            .order('created_at', { ascending: false });
          if (emailError) {
            console.warn('DB fetch failed:', emailError.message);
            return NextResponse.json({
              success: true,
              services: [],
            });
          }
          return NextResponse.json({
            success: true,
            services: emailData || [],
          });
        }

        console.warn('DB fetch failed:', error.message);
        return NextResponse.json({
          success: true,
          services: [],
        });
      }
      
      return NextResponse.json({
        success: true,
        services: data || [],
      });
    }
    
    // 전체 서비스 목록 조회
    const { data, error } = await sb
      .from('services')
      .select('id, name, description, slug, created_at')
      .order('created_at', { ascending: false })
      .limit(50);
    
    if (error) {
      console.warn('DB fetch failed, using memory store:', error.message);
      const allServices = Array.from(servicesStore.values()).map(s => ({
        id: s.id,
        name: s.name,
        description: s.description,
        slug: s.slug,
        createdAt: s.createdAt,
      }));
      
      return NextResponse.json({
        success: true,
        services: allServices,
      });
    }
    
    return NextResponse.json({
      success: true,
      services: data || [],
    });
  } catch (error) {
    console.error('Service fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch services' },
      { status: 500 }
    );
  }
}

// 서비스 삭제
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { error: 'Service ID is required' },
        { status: 400 }
      );
    }
    
    // 현재 사용자 ID 가져오기
    const currentUser = await getCurrentUser(request);
    if (!currentUser) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    const supabase = getSupabaseAdmin();
    
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const sb = supabase as any;
    
    // 서비스 소유권 확인 후 삭제
    const { data: service, error: fetchError } = await sb
      .from('services')
      .select('user_id, contact_email')
      .eq('id', id)
      .single();
    
    if (fetchError || !service) {
      if (fetchError?.message?.includes('column "user_id" does not exist')) {
        if (!currentUser.email) {
          return NextResponse.json(
            { error: 'Permission denied' },
            { status: 403 }
          );
        }
        const { data: emailService, error: emailError } = await sb
          .from('services')
          .select('contact_email')
          .eq('id', id)
          .single();
        if (emailError || !emailService) {
          return NextResponse.json(
            { error: 'Service not found' },
            { status: 404 }
          );
        }
        if (emailService.contact_email !== currentUser.email) {
          return NextResponse.json(
            { error: 'Permission denied' },
            { status: 403 }
          );
        }
      } else {
        return NextResponse.json(
          { error: 'Service not found' },
          { status: 404 }
        );
      }
    } else {
      if (service.user_id !== currentUser.id) {
        return NextResponse.json(
          { error: 'Permission denied' },
          { status: 403 }
        );
      }
    }
    
    // 삭제 실행
    const { error: deleteError } = await sb
      .from('services')
      .delete()
      .eq('id', id);
    
    if (deleteError) {
      console.error('Delete error:', deleteError);
      return NextResponse.json(
        { error: 'Failed to delete service' },
        { status: 500 }
      );
    }
    
    return NextResponse.json({
      success: true,
      message: 'Service deleted successfully',
    });
  } catch (error) {
    console.error('Service delete error:', error);
    return NextResponse.json(
      { error: 'Failed to delete service' },
      { status: 500 }
    );
  }
}

// 서비스 수정
export async function PUT(request: NextRequest) {
  try {
    const serviceData: ServiceData & { id?: string } = await request.json();

    if (!serviceData.id) {
      return NextResponse.json(
        { error: 'Service ID is required' },
        { status: 400 }
      );
    }

    const currentUser = await getCurrentUser(request);
    if (!currentUser) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const supabase = getSupabaseAdmin();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const sb = supabase as any;

    const { data: existing, error: fetchError } = await sb
      .from('services')
      .select('id, slug, user_id, contact_email')
      .eq('id', serviceData.id)
      .single();

    const effectiveName = serviceData.name || serviceData.nameKo;
    const effectiveDescription = serviceData.description || serviceData.descriptionKo;
    if (!effectiveName || !effectiveDescription) {
      return NextResponse.json(
        { error: 'Missing required fields: name, description' },
        { status: 400 }
      );
    }

    const normalizedService: ServiceData = {
      ...serviceData,
      name: effectiveName,
      description: effectiveDescription,
    };

    if (fetchError || !existing) {
      if (fetchError?.message?.includes('Supabase not configured')) {
        const stored = servicesStore.get(serviceData.id);
        if (!stored) {
          return NextResponse.json(
            { error: 'Service not found' },
            { status: 404 }
          );
        }
        const slug = stored.slug || generateSlug(normalizedService.name);
        const aiTxt = generateAiTxt(normalizedService, slug);
        const jsonLd = generateJsonLd(normalizedService, slug);
        servicesStore.set(serviceData.id, {
          ...stored,
          ...normalizedService,
          slug,
          aiTxt,
          jsonLd,
        });
        return NextResponse.json({ success: true });
      }

      return NextResponse.json(
        { error: 'Service not found' },
        { status: 404 }
      );
    }

    if (existing.user_id && existing.user_id !== currentUser.id) {
      return NextResponse.json(
        { error: 'Permission denied' },
        { status: 403 }
      );
    }

    if (!existing.user_id && currentUser.email && existing.contact_email && existing.contact_email !== currentUser.email) {
      return NextResponse.json(
        { error: 'Permission denied' },
        { status: 403 }
      );
    }

    const slug = existing.slug || generateSlug(normalizedService.name);
    const aiTxt = generateAiTxt(normalizedService, slug);
    const jsonLd = generateJsonLd(normalizedService, slug);

    const updatePayload = {
      name: normalizedService.name,
      name_ko: serviceData.nameKo,
      description: normalizedService.description,
      description_ko: serviceData.descriptionKo,
      homepage: serviceData.homepage,
      api_base: serviceData.apiBase,
      endpoints: serviceData.endpoints,
      auth_type: serviceData.authType,
      rate_limit: serviceData.rateLimit,
      contact_email: serviceData.contactEmail,
      ai_txt: aiTxt,
      json_ld: jsonLd,
    };

    const { error: updateError } = await sb
      .from('services')
      .update(updatePayload)
      .eq('id', serviceData.id);

    if (updateError) {
      return NextResponse.json(
        { error: 'Failed to update service', details: updateError.message },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Service update error:', error);
    return NextResponse.json(
      { error: 'Failed to update service' },
      { status: 500 }
    );
  }
}
