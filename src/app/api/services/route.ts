import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseClient } from '@/lib/supabase/client';

export const runtime = 'edge';

interface ServiceData {
  id?: string;
  name: string;
  nameKo?: string;
  description: string;
  descriptionKo?: string;
  homepage: string;
  apiBase: string;
  endpoints: {
    id: string;
    path: string;
    method: string;
    description: string;
    auth: boolean;
    params: string;
  }[];
  authType: string;
  rateLimit: string;
  contactEmail: string;
  slug?: string;
  createdAt?: string;
}

// 메모리 저장소 (DB 미연결 시 폴백)
const servicesStore = new Map<string, ServiceData & { aiTxt: string; jsonLd: object }>();

// 슬러그 생성 (간단한 버전)
function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 30) + '-' + Date.now().toString(36);
}

// ai.txt 형식으로 변환
function generateAiTxt(service: ServiceData, slug: string): string {
  return `# =============================================================================
# ${service.name} AI Interaction Specification (ai.txt)
# Generated by Eoynx Agent Gateway
# Hosted at: https://eoynx.com/s/${slug}
# =============================================================================

[System.Context]
Name: ${service.name}
${service.nameKo ? `Name_KO: ${service.nameKo}` : ''}
Description: ${service.description}
${service.descriptionKo ? `Description_KO: ${service.descriptionKo}` : ''}
Homepage: ${service.homepage}
Contact: ${service.contactEmail}

[API.Base]
URL: ${service.apiBase}

[API.Endpoints]
${service.endpoints.map((ep, i) => `
## ${i + 1}. ${ep.description || 'Endpoint'}
Endpoint: ${ep.method} ${service.apiBase}${ep.path}
Auth: ${ep.auth ? 'Required' : 'Not Required'}
${ep.params ? `Parameters: ${ep.params}` : ''}`).join('\n')}

[Authentication.Policy]
Type: ${service.authType === 'none' ? 'None' : service.authType === 'api_key' ? 'API Key' : service.authType === 'jwt' ? 'JWT Bearer Token' : 'OAuth 2.0'}
${service.authType !== 'none' ? `Header: ${service.authType === 'api_key' ? 'X-API-Key' : 'Authorization: Bearer <token>'}` : ''}

[Rate.Limits]
Default: ${service.rateLimit}

# =============================================================================
# Generated via Eoynx Agent Gateway
# https://eoynx.com
# =============================================================================
`;
}

// JSON-LD 형식으로 변환
function generateJsonLd(service: ServiceData, slug: string): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'WebAPI',
    '@id': `https://eoynx.com/s/${slug}`,
    name: service.name,
    alternateName: service.nameKo || undefined,
    description: service.description,
    url: service.homepage,
    documentation: `${service.homepage}/docs`,
    provider: {
      '@type': 'Organization',
      name: service.name,
      email: service.contactEmail,
    },
    endpointUrl: service.apiBase,
    potentialAction: service.endpoints.map(ep => ({
      '@type': ep.method === 'GET' ? 'ReadAction' : 'Action',
      name: ep.description || ep.path,
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${service.apiBase}${ep.path}`,
        httpMethod: ep.method,
      },
    })),
    additionalProperty: [
      {
        '@type': 'PropertyValue',
        name: 'authType',
        value: service.authType,
      },
      {
        '@type': 'PropertyValue',
        name: 'rateLimit',
        value: service.rateLimit,
      },
    ],
  };
}

export async function POST(request: NextRequest) {
  try {
    const serviceData: ServiceData = await request.json();
    
    // 필수 필드 검증
    if (!serviceData.name || !serviceData.apiBase || !serviceData.description) {
      return NextResponse.json(
        { error: 'Missing required fields: name, apiBase, description' },
        { status: 400 }
      );
    }
    
    // 슬러그 생성
    const slug = generateSlug(serviceData.name);
    const id = crypto.randomUUID();
    const now = new Date().toISOString();
    const aiTxt = generateAiTxt(serviceData, slug);
    const jsonLd = generateJsonLd(serviceData, slug);
    
    const supabase = getSupabaseClient();
    
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const sb = supabase as any;
    
    // Supabase에 저장 시도
    const { data, error } = await sb
      .from('services')
      .insert({
        id,
        slug,
        name: serviceData.name,
        name_ko: serviceData.nameKo,
        description: serviceData.description,
        description_ko: serviceData.descriptionKo,
        homepage: serviceData.homepage,
        api_base: serviceData.apiBase,
        endpoints: serviceData.endpoints,
        auth_type: serviceData.authType,
        rate_limit: serviceData.rateLimit,
        contact_email: serviceData.contactEmail,
        ai_txt: aiTxt,
        json_ld: jsonLd,
        created_at: now,
      })
      .select()
      .single();
    
    if (error) {
      console.warn('DB save failed, using memory store:', error.message);
      // 메모리에 저장
      servicesStore.set(id, {
        ...serviceData,
        id,
        slug,
        createdAt: now,
        aiTxt,
        jsonLd,
      });
    }
    
    const result = {
      id: data?.id || id,
      slug: data?.slug || slug,
      name: serviceData.name,
      createdAt: data?.created_at || now,
      urls: {
        dashboard: `https://eoynx.com/s/${slug}`,
        aiTxt: `https://eoynx.com/s/${slug}/ai.txt`,
        llmsTxt: `https://eoynx.com/s/${slug}/llms.txt`,
        jsonLd: `https://eoynx.com/s/${slug}/json-ld`,
      },
    };
    
    return NextResponse.json({
      success: true,
      slug,
      service: result,
      preview: {
        aiTxt,
        jsonLd,
      },
    }, {
      status: 201,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  } catch (error) {
    console.error('Service creation error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { 
        error: 'Failed to create service',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const slug = searchParams.get('slug');
    
    const supabase = getSupabaseClient();
    
    // 특정 slug로 조회
    if (slug) {
      const { data, error } = await supabase
        .from('services')
        .select('*')
        .eq('slug', slug)
        .single();
      
      if (error || !data) {
        // 메모리에서 조회
        for (const [, service] of servicesStore) {
          if (service.slug === slug) {
            return NextResponse.json({
              success: true,
              service,
            });
          }
        }
        return NextResponse.json(
          { error: 'Service not found' },
          { status: 404 }
        );
      }

      return NextResponse.json({
        success: true,
        service: data,
      });
    }
    
    // 전체 서비스 목록 조회
    const { data, error } = await supabase
      .from('services')
      .select('id, name, description, slug, created_at')
      .order('created_at', { ascending: false })
      .limit(50);
    
    if (error) {
      console.warn('DB fetch failed, using memory store:', error.message);
      const allServices = Array.from(servicesStore.values()).map(s => ({
        id: s.id,
        name: s.name,
        description: s.description,
        slug: s.slug,
        createdAt: s.createdAt,
      }));
      
      return NextResponse.json({
        success: true,
        services: allServices,
      });
    }
    
    return NextResponse.json({
      success: true,
      services: data || [],
    });
  } catch (error) {
    console.error('Service fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch services' },
      { status: 500 }
    );
  }
}
